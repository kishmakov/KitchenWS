{% extends "doc/base.html" %}

{% load staticfiles %}

{% block content %}
<div class="row">
    <h1 class="text-center">Computational Element</h1>
    <hr>
</div>

<div class="row">
    <div class="col-md-10 col-md-offset-1">
        <h3>Atomic Elements</h3>
        <p>
            Computational element is an ideological cornerstone of the Kitchen platform.
            From the mathematical point of view, computational element is just a function
            with properly defined domain and range. From the philosophically point of view,
            it is a "potentiality" which turns into a "certainty" once "definiteness"
            is provided. We would designate computational elements as follows:
        </p>
        <img src="{% static "images/computational_element_00.png" %}"
             alt="Computational Element Intro" class="kitchen-doc-img">
        <p>
            Computational element consists of inputs (golden) and outputs (purple).
            Both inputs and outputs could be defined or undefined. We distinguish defined
            items by designating them "being filled with water", as shown at the picture
            below. While at least one of the inputs of an element is undefined, element
            represents some potential computation which could be triggered by providing
            values into the remaining undefined inputs (<i>a</i>). Once all of the inputs
            are defined, element is activated and computation starts. When the computation
            is finished, defined values are provided for all of element's outputs (<i>b</i>).
        </p>
        <img src="{% static "images/computational_element_01.png" %}"
             alt="Computational Element States" class="kitchen-doc-img">
        <p>
            Computation elements vary in size. Smallest elements correspond to machine
            instructions. They are built in the Kitchen and their execution is performed
            by means of underlying machine. Two examples are provided at the picture below.
            First example (<i>a</i>) is one of the smallest elements possible. It
            is simple summation of its two inputs. Second example (<i>b</i>) is an element
            which accepts array as its first input and index as its second input and
            returns array element at given index.
        </p>
        <img src="{% static "images/computational_element_02.png" %}"
             alt="Atomic Element Examples" class="kitchen-doc-img">
        <p>
            Big computational elements outsize logical building blocks of underlying machine.
            Such elements require decomposition in order to be handled by the Kitchen system.
        </p>
        <h3>Composed Elements</h3>
        <p>
            We would like to choose a decomposition of the computational element based on
            the philosophical point of view on the subject. According to this point of view
            element's essence is enclosed in the "potentiality" represented by it. For
            instances, consider a computational element which solves quadratic equation.
            Our first and most rough idea about it would be nearly as follows.
        </p>
        <img src="{% static "images/computational_element_03.png" %}"
             alt="Quadratic Equation Solver No Clue" class="kitchen-doc-img">
        <p>
            The equation itself is not something we are interested in, but the solution of
            the equation. In order to clarify what we mean by solution we need to take into
            account the setting in which equation arise. Let us additionally assume that this
            equation implied by following simple physics problem.
        </p>
        <blockquote>Boy throws a stone from atop of the tree and is interested in time when
            the stone would land on the ground.
        </blockquote>
        <p>
            Provided such a setting, we could deduce two additional assumption about solution
            of the derived equation. First assumption is that equation is not degenerate,
            because leading coefficient is proportional to the <rus>тяготение</rus> constant.
            Therefore three coefficients define our equation. Second assumption is that equation
            would always have only real roots. This considerations excludes necessity of handling
            complex roots and branching on degeneracy of the equation. As a result we could specify
            our element's inputs and output as follows.
        </p>
        <img src="{% static "images/computational_element_04.png" %}"
             alt="Quadratic Equation Solver Outputs Specified" class="kitchen-doc-img">
        <p>

        </p>
        <p>
            In order to represent computational element as Prior to start decomposition
            Big computational elements outsize logical building blocks of underlying machine
            and therefore should be "decomposed". First step of decomposition is the
            encapsulation of exterior perception of an element. In order to do this we
            recall philosophical point of view of the computational element.
        </p>
        <p>
            The "potentiality" which is enclosed inside element is the understanding of
            element outcome. It means that we now type of each element's output. By understanding we mean that we exactly know type of the result. The "definiteness", which should be injected into element,
            comes in through
            travels through

            While there is no "definiteness", element provides some "potentiality". This
            mean that we know,        what we need to provide and what we would get as the result.
        </p>

        <p>
            Let us consider computational element which solves quadratic equation.
        </p>

        <p>
            Kitchen is a platform for building computational algorithms. Computational
            algorithms vary in their size. While "small" algorithm could be treated
            as a whole both as an idea and as a computer representation, "big"
            algorithms are different. Standard approach to this problem is a
            modularization of "big" algorithms at the level of idea and in its
            computer representation.
        </p>
        <br>
        <p>
            Cornerstone of the Kitchen modularization system is the notion of the <b>symbol</b>.
            Philosophically speaking symbol is everything which could be expressed, used
            in expressions and defined. Expressions are aimed to define one symbol via
            another symbols by means of algorithmic terms.
        </p>
        <br>
        <p>
            Symbols are consumables of computation in the sense that once computation started,
            symbols are consequently get defined into numeric values. In a metaphoric way,
            you could think symbols like a pipes. These pipes are supposed to be filled with
            "definiteness" flow. When you define symbol, say A, via expression containing other
            symbols, say B and C, you connect the input of A-pipe to the output of B- and C-pipes.
        </p>
        <br>
        <p>
            These symbol dualities are reflected in notations (compare with
            <a href="http://en.wikipedia.org/wiki/Symbol#Etymology">original meaning</a> of the word).
            The ability to act as an input, i.e. to be expressed and subsequently transfer
            the definiteness further is depicted with gold trapezoid tapering to the top.
            The ability to act as an output, i.e. to be part of other symbols expressions
            and to inject definiteness into them is depicted with purple trapezoid widening
            to the top. See figure below.
        </p>
        <br>
        <img src="{% static "images/symbols_together.png" %}"
             alt="Symbol: Input -- Output -- Complete" class="kitchen-doc-img">
        <br>
        <p>
            Acquaintance with modularization through symbols is better to start with a toy example.
            Let us take this example to be quadratic equation solution algorithm. Let us
            formulate the problem as follows.
        </p>
        <br>
        <blockquote>Given coefficients $a$, $b$ and $c$. Provided that equation $ax^2 + bx + c$
            has different roots, one need to find these roots denoted as $x_1$ and $x_2$.
        </blockquote>
        <br>
        <p>
            By algorithmic solution we mean such an algorithm that express $x_1$ and $x_2$ by
            means of coefficient symbols $a$, $b$ and $c$. Provided such an algorithm,
            once we define those coefficients symbols we could subsequently eliminate all
            undefined symbols up until $x_1$ and $x_2$. An example of such an expression
            is presented below.
        </p>
        <br>
        <img src="{% static "images/quadratic_equation_simple.png" %}"
             alt="Simple Quadratic Equation" class="kitchen-doc-img">
        <br>
        <p>
            This diagram depicts two algorithmic modules (each corresponds to a green bar).
            They have same shared input symbols $a$, $b$ and $c$. These symbols are waiting for
            either expression or definition in order to stop being inputs.
            Symbols $x_1$  and $x_2$ are respective outputs and they are already expressed.
            They are waiting for some usage in order to finish their service.
        </p>
        <br>
        <p>
            Such modules are used as building blocks for construction of modularized algorithms.
            During modularized algorithm construction we join outputs of some modules with inputs
            of some other modules. When construction process is ended, uncompleted input
            (cor. output) symbols are the inputs (cor. outputs) of resulting algorithm. Thus
            the result of joining of algorithmic modules is again an algorithmic module.
        </p>
        <br>
        <p>
            All the outputs of algorithmic module must be expressed via input symbols.
            All the inputs are should be ready to be either expressed or defined with numeric value.
            These assumptions let us speak about two natures of every module: <b>mama</b>-nature
            and <b>papa</b>-nature.
        </p>
        <br>
        <p>
            Mama-nature manifests in the ability of the module to perform it computational function
            independently of the way its inputs defined: by expressions or by numeric values.
            In other words, module should be open to every scenario. On the contrary,
            papa-nature manifests in the necessity to pass further only expressed symbols.
            This brings some "invariant" into the idea of the module: module decreases uncertainty.
        </p>
        <br>
        <p>
            Let us consider another modularization of quadratic equation solution.
        </p>
        <br>
        <img src="{% static "images/quadratic_equation_modularized.png" %}"
             alt="Modularized Quadratic Equation" class="kitchen-doc-img">
        <br>
        <p>
            This scheme naturally reflects the point of discriminant being a part of the algorithmic
            solution. Discriminant computation is encapsulated into separate submodule. This submodule
            injects its definiteness into submodules which compute $x_1$ and $x_2$. Flexibility of
            inputs of these submodules is presented in fact that part of their inputs left intact
            ($a$ and $b$), while other part of their inputs is expressed with other symbols ($D$).
        </p>
        <br>
        <p>
            Although it is not quite obvious from this example, such encapsulations help us
            to reduce complexity of submodules and manage control over them. This approach
            is intended to allow us to deal with algorithms of higher complexity.
        </p>
        <br>
        <p>
            Another modularization is presented below as well.
        </p>
        <br>
        <img src="{% static "images/quadratic_equation_last.png" %}"
             alt="Another Modularization of Quadratic Equation" class="kitchen-doc-img">
        <br>
        <p>
            You could note that there is a submodule in this scheme which defines two output symbols.
        </p>
    </div>
</div>
{% endblock %}

