{% extends "doc/base.html" %}

{% load staticfiles %}

{% block content %}
<div class="row">
    <h1 class="text-center">Computational Element</h1>
    <hr>
</div>

<div class="row">
    <div class="col-md-10 col-md-offset-1">
        <br>
        <p>
            Computational element is an ideological cornerstone of the Kitchen platform.
            From the mathematical point of view, computational element is just a function
            with properly defined domain and range. From the philosophically point of view,
            it is a "potentiality" which turns into a "certainty" once "definiteness"
            is provided. We would designate computational elements as follows:
        </p>
        <img src="{% static "images/computational_element_00.png" %}"
             alt="Computational Element Intro" class="kitchen-doc-img">
        <p>
            Computational element consists of inputs (golden) and outputs (purple).
            While some of its inputs are undefined, it represents some potential
            computation which could be triggered by providing values into the remaining
            undefined inputs. See <i>a</i> of the picture below. Once all of its
            inputs are defined, computational element is activated. When the computation
            is finished, all outputs are defined. See <i>b</i> of the picture below.
        </p>
        <img src="{% static "images/computational_element_01.png" %}"
             alt="Computational Element States" class="kitchen-doc-img">
        <p>
            Computation elements vary in sizes. Smallest elements correspond to machine
            instructions. They are built in the Kitchen and their execution is performed
            by means of underlying machine. Two examples are provided at the picture below.
            First example (<i>a</i>) is one of the smallest elements possible. It
            is simple summation of its two inputs. Second example (<i>b</i>) is an element
            which accepts array as its first input and index as its second input and
            returns array element at given index.
        </p>
        <img src="{% static "images/computational_element_02.png" %}"
             alt="Computational Element States" class="kitchen-doc-img">

        <p>
            Kitchen is a platform for building computational algorithms. Computational
            algorithms vary in their size. While "small" algorithm could be treated
            as a whole both as an idea and as a computer representation, "big"
            algorithms are different. Standard approach to this problem is a
            modularization of "big" algorithms at the level of idea and in its
            computer representation.
        </p>
        <br>
        <p>
            Cornerstone of the Kitchen modularization system is the notion of the <b>symbol</b>.
            Philosophically speaking symbol is everything which could be expressed, used
            in expressions and defined. Expressions are aimed to define one symbol via
            another symbols by means of algorithmic terms.
        </p>
        <br>
        <p>
            Symbols are consumables of computation in the sense that once computation started,
            symbols are consequently get defined into numeric values. In a metaphoric way,
            you could think symbols like a pipes. These pipes are supposed to be filled with
            "definiteness" flow. When you define symbol, say A, via expression containing other
            symbols, say B and C, you connect the input of A-pipe to the output of B- and C-pipes.
        </p>
        <br>
        <p>
            These symbol dualities are reflected in notations (compare with
            <a href="http://en.wikipedia.org/wiki/Symbol#Etymology">original meaning</a> of the word).
            The ability to act as an input, i.e. to be expressed and subsequently transfer
            the definiteness further is depicted with gold trapezoid tapering to the top.
            The ability to act as an output, i.e. to be part of other symbols expressions
            and to inject definiteness into them is depicted with purple trapezoid widening
            to the top. See figure below.
        </p>
        <br>
        <img src="{% static "images/symbols_together.png" %}"
             alt="Symbol: Input -- Output -- Complete" class="kitchen-doc-img">
        <br>
        <p>
            Acquaintance with modularization through symbols is better to start with a toy example.
            Let us take this example to be quadratic equation solution algorithm. Let us
            formulate the problem as follows.
        </p>
        <br>
        <blockquote>Given coefficients $a$, $b$ and $c$. Provided that equation $ax^2 + bx + c$
            has different roots, one need to find these roots denoted as $x_1$ and $x_2$.
        </blockquote>
        <br>
        <p>
            By algorithmic solution we mean such an algorithm that express $x_1$ and $x_2$ by
            means of coefficient symbols $a$, $b$ and $c$. Provided such an algorithm,
            once we define those coefficients symbols we could subsequently eliminate all
            undefined symbols up until $x_1$ and $x_2$. An example of such an expression
            is presented below.
        </p>
        <br>
        <img src="{% static "images/quadratic_equation_simple.png" %}"
             alt="Simple Quadratic Equation" class="kitchen-doc-img">
        <br>
        <p>
            This diagram depicts two algorithmic modules (each corresponds to a green bar).
            They have same shared input symbols $a$, $b$ and $c$. These symbols are waiting for
            either expression or definition in order to stop being inputs.
            Symbols $x_1$  and $x_2$ are respective outputs and they are already expressed.
            They are waiting for some usage in order to finish their service.
        </p>
        <br>
        <p>
            Such modules are used as building blocks for construction of modularized algorithms.
            During modularized algorithm construction we join outputs of some modules with inputs
            of some other modules. When construction process is ended, uncompleted input
            (cor. output) symbols are the inputs (cor. outputs) of resulting algorithm. Thus
            the result of joining of algorithmic modules is again an algorithmic module.
        </p>
        <br>
        <p>
            All the outputs of algorithmic module must be expressed via input symbols.
            All the inputs are should be ready to be either expressed or defined with numeric value.
            These assumptions let us speak about two natures of every module: <b>mama</b>-nature
            and <b>papa</b>-nature.
        </p>
        <br>
        <p>
            Mama-nature manifests in the ability of the module to perform it computational function
            independently of the way its inputs defined: by expressions or by numeric values.
            In other words, module should be open to every scenario. On the contrary,
            papa-nature manifests in the necessity to pass further only expressed symbols.
            This brings some "invariant" into the idea of the module: module decreases uncertainty.
        </p>
        <br>
        <p>
            Let us consider another modularization of quadratic equation solution.
        </p>
        <br>
        <img src="{% static "images/quadratic_equation_modularized.png" %}"
             alt="Modularized Quadratic Equation" class="kitchen-doc-img">
        <br>
        <p>
            This scheme naturally reflects the point of discriminant being a part of the algorithmic
            solution. Discriminant computation is encapsulated into separate submodule. This submodule
            injects its definiteness into submodules which compute $x_1$ and $x_2$. Flexibility of
            inputs of these submodules is presented in fact that part of their inputs left intact
            ($a$ and $b$), while other part of their inputs is expressed with other symbols ($D$).
        </p>
        <br>
        <p>
            Although it is not quite obvious from this example, such encapsulations help us
            to reduce complexity of submodules and manage control over them. This approach
            is intended to allow us to deal with algorithms of higher complexity.
        </p>
        <br>
        <p>
            Another modularization is presented below as well.
        </p>
        <br>
        <img src="{% static "images/quadratic_equation_last.png" %}"
             alt="Another Modularization of Quadratic Equation" class="kitchen-doc-img">
        <br>
        <p>
            You could note that there is a submodule in this scheme which defines two output symbols.
        </p>
    </div>
</div>
{% endblock %}

